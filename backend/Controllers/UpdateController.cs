using Microsoft.AspNetCore.Mvc;
using backend.Services;
using backend.Models.Entities;
using Swashbuckle.AspNetCore.Annotations;
using System.Text.Json.Serialization;

namespace backend.Controllers
{
    [ApiController]
    [Route("api/[controller]")]
    [SwaggerTag("Управление обновлениями данных")]
    public class UpdateController : ControllerBase
    {
        private readonly IUpdateService _updateService;
        private readonly ILogger<UpdateController> _logger;

        public UpdateController(IUpdateService updateService, ILogger<UpdateController> logger)
        {
            _updateService = updateService;
            _logger = logger;
        }

        [HttpPost("process-pending")]
        [SwaggerOperation(Summary = "Обработать все ожидающие обновления")]
        [SwaggerResponse(200, "Обновления обработаны", typeof(object))]
        [SwaggerResponse(500, "Ошибка сервера")]
        public async Task<ActionResult> ProcessPendingUpdates()
        {
            try
            {
                var processedCount = await _updateService.ProcessAllPendingUpdatesAsync();
                return Ok(new { 
                    processedCount, 
                    message = $"Обработано {processedCount} обновлений",
                    timestamp = DateTime.UtcNow
                });
            }
            catch (Exception ex)
            {
                _logger.LogError(ex, "Error processing pending updates");
                return StatusCode(500, new { error = "Ошибка при обработке обновлений", details = ex.Message });
            }
        }

        [HttpGet("status")]
        [SwaggerOperation(Summary = "Получить статус обновлений")]
        [SwaggerResponse(200, "Статус получен", typeof(UpdateStatus))]
        [SwaggerResponse(500, "Ошибка сервера")]
        public async Task<ActionResult<UpdateStatus>> GetUpdateStatus()
        {
            try
            {
                var status = await _updateService.GetUpdateStatusAsync();
                return Ok(status);
            }
            catch (Exception ex)
            {
                _logger.LogError(ex, "Error getting update status");
                return StatusCode(500, new { error = "Ошибка при получении статуса" });
            }
        }

        [HttpPost("prices")]
        [SwaggerOperation(Summary = "Загрузить обновления цен")]
        [SwaggerResponse(200, "Обновления загружены")]
        [SwaggerResponse(400, "Неверный запрос")]
        [SwaggerResponse(500, "Ошибка сервера")]
        public async Task<ActionResult> UploadPriceUpdates([FromBody] PriceUpdateRequest request)
        {
            try
            {
                if (request?.ArrayOfPriceEl == null)
                    return BadRequest(new { error = "Неверный формат данных обновлений цен" });

                // КОНВЕРТАЦИЯ: преобразуем DTO в Entity
                var priceUpdates = request.ArrayOfPriceEl.Select(dto => new PriceUpdate
                {
                    ID = 0, // Auto-generated by DB
                    ProductId = dto.ID, // Используем ID из JSON как ProductId
                    StockId = dto.IDStock, // Используем IDStock из JSON как StockId
                    PriceT = dto.PriceT,
                    PriceT1 = dto.PriceT1,
                    PriceT2 = dto.PriceT2,
                    PriceM = dto.PriceM,
                    PriceM1 = dto.PriceM1,
                    PriceM2 = dto.PriceM2,
                    PriceLimitT1 = dto.PriceLimitT1,
                    PriceLimitT2 = dto.PriceLimitT2,
                    PriceLimitM1 = dto.PriceLimitM1,
                    PriceLimitM2 = dto.PriceLimitM2,
                    NDS = dto.NDS,
                    UpdatedAt = DateTime.UtcNow,
                    IsProcessed = false
                }).ToList();

                var result = await _updateService.ProcessPriceUpdatesAsync(priceUpdates);
                
                return Ok(new { 
                    message = "Обновления цен успешно загружены",
                    processedItems = result.ProcessedCount,
                    timestamp = DateTime.UtcNow
                });
            }
            catch (Exception ex)
            {
                _logger.LogError(ex, "Error uploading price updates");
                return StatusCode(500, new { error = "Ошибка при загрузке обновлений цен", details = ex.Message });
            }
        }

        [HttpPost("remnants")]
        [SwaggerOperation(Summary = "Загрузить обновления остатков")]
        [SwaggerResponse(200, "Обновления загружены")]
        [SwaggerResponse(400, "Неверный запрос")]
        [SwaggerResponse(500, "Ошибка сервера")]
        public async Task<ActionResult> UploadRemnantUpdates([FromBody] RemnantUpdateRequest request)
        {
            try
            {
                if (request?.ArrayOfRemnantsEl == null)
                    return BadRequest(new { error = "Неверный формат данных обновлений остатков" });

                var result = await _updateService.ProcessRemnantUpdatesAsync(request.ArrayOfRemnantsEl);
                
                return Ok(new { 
                    message = "Обновления остатков успешно загружены",
                    processedItems = result.ProcessedCount,
                    timestamp = DateTime.UtcNow
                });
            }
            catch (Exception ex)
            {
                _logger.LogError(ex, "Error uploading remnant updates");
                return StatusCode(500, new { error = "Ошибка при загрузке обновлений остатков", details = ex.Message });
            }
        }

        [HttpPost("stocks")]
        [SwaggerOperation(Summary = "Загрузить обновления складов")]
        [SwaggerResponse(200, "Обновления загружены")]
        [SwaggerResponse(400, "Неверный запрос")]
        [SwaggerResponse(500, "Ошибка сервера")]
        public async Task<ActionResult> UploadStockUpdates([FromBody] StockUpdateRequest request)
        {
            try
            {
                if (request?.ArrayOfStockEl == null)
                    return BadRequest(new { error = "Неверный формат данных обновлений складов" });

                var result = await _updateService.ProcessStockUpdatesAsync(request.ArrayOfStockEl);
                
                return Ok(new { 
                    message = "Обновления складов успешно загружены",
                    processedItems = result.ProcessedCount,
                    timestamp = DateTime.UtcNow
                });
            }
            catch (Exception ex)
            {
                _logger.LogError(ex, "Error uploading stock updates");
                return StatusCode(500, new { error = "Ошибка при загрузке обновлений складов", details = ex.Message });
            }
        }

        [HttpGet("logs")]
        [SwaggerOperation(Summary = "Получить логи обновлений")]
        [SwaggerResponse(200, "Логи получены", typeof(List<UpdateLog>))]
        [SwaggerResponse(500, "Ошибка сервера")]
        public async Task<ActionResult<List<UpdateLog>>> GetUpdateLogs(
            [FromQuery] DateTime? from = null,
            [FromQuery] DateTime? to = null)
        {
            try
            {
                var startDate = from ?? DateTime.UtcNow.AddDays(-1);
                var endDate = to ?? DateTime.UtcNow;

                var logs = await _updateService.GetUpdateLogsAsync(startDate, endDate);
                return Ok(logs);
            }
            catch (Exception ex)
            {
                _logger.LogError(ex, "Error getting update logs");
                return StatusCode(500, new { error = "Ошибка при получении логов" });
            }
        }

        [HttpPost("cleanup")]
        [SwaggerOperation(Summary = "Очистить обработанные обновления")]
        [SwaggerResponse(200, "Очистка выполнена")]
        [SwaggerResponse(500, "Ошибка сервера")]
        public async Task<ActionResult> CleanupProcessedUpdates([FromQuery] int daysOld = 7)
        {
            try
            {
                if (daysOld < 1)
                    return BadRequest(new { error = "Параметр daysOld должен быть больше 0" });

                var olderThan = DateTime.UtcNow.AddDays(-daysOld);
                var result = await _updateService.CleanupProcessedUpdatesAsync(olderThan);
                
                if (result)
                    return Ok(new { 
                        message = $"Обработанные обновления старше {daysOld} дней очищены",
                        cleanedUpTo = olderThan
                    });
                else
                    return BadRequest(new { error = "Ошибка при очистке обновлений" });
            }
            catch (Exception ex)
            {
                _logger.LogError(ex, "Error cleaning up updates");
                return StatusCode(500, new { error = "Ошибка при очистке обновлений", details = ex.Message });
            }
        }

        [HttpPost("force-sync")]
        [SwaggerOperation(Summary = "Принудительная полная синхронизация")]
        [SwaggerResponse(200, "Синхронизация запущена")]
        [SwaggerResponse(500, "Ошибка сервера")]
        public async Task<ActionResult> ForceFullSync()
        {
            try
            {
                var result = await _updateService.ForceFullSyncAsync();
                
                if (result)
                    return Ok(new { message = "Полная синхронизация запущена" });
                else
                    return BadRequest(new { error = "Ошибка при запуске синхронизации" });
            }
            catch (Exception ex)
            {
                _logger.LogError(ex, "Error forcing full sync");
                return StatusCode(500, new { error = "Ошибка при запуске синхронизации", details = ex.Message });
            }
        }

        [HttpPost("process-specific")]
        [SwaggerOperation(Summary = "Обработать конкретный тип обновлений")]
        [SwaggerResponse(200, "Обновления обработаны")]
        [SwaggerResponse(400, "Неверный тип обновлений")]
        [SwaggerResponse(500, "Ошибка сервера")]
        public async Task<ActionResult> ProcessSpecificUpdates([FromQuery] string updateType)
        {
            try
            {
                int processedCount = 0;
                
                switch (updateType?.ToLower())
                {
                    case "prices":
                        processedCount = await _updateService.ProcessPriceUpdatesBatchAsync();
                        break;
                    case "remnants":
                        processedCount = await _updateService.ProcessRemnantUpdatesBatchAsync();
                        break;
                    case "stocks":
                        processedCount = await _updateService.ProcessStockUpdatesBatchAsync();
                        break;
                    default:
                        return BadRequest(new { 
                            error = "Неверный тип обновлений", 
                            validTypes = new[] { "prices", "remnants", "stocks" }
                        });
                }

                return Ok(new { 
                    processedCount, 
                    updateType,
                    message = $"Обработано {processedCount} обновлений типа {updateType}"
                });
            }
            catch (Exception ex)
            {
                _logger.LogError(ex, $"Error processing {updateType} updates");
                return StatusCode(500, new { error = $"Ошибка при обработке обновлений типа {updateType}" });
            }
        }
    }

    // DTO классы для приема JSON
    public class PriceUpdateRequest
    {
        [JsonPropertyName("ArrayOfPricesEl")]
        public List<PriceUpdateDto> ArrayOfPriceEl { get; set; } = new();
    }

    public class PriceUpdateDto
    {
        [JsonPropertyName("ID")]
        public int ID { get; set; }
        
        [JsonPropertyName("IDStock")] 
        public string IDStock { get; set; } = string.Empty;
        
        public decimal? PriceT { get; set; }
        public decimal? PriceT1 { get; set; }
        public decimal? PriceT2 { get; set; }
        public decimal? PriceM { get; set; }
        public decimal? PriceM1 { get; set; }
        public decimal? PriceM2 { get; set; }
        public decimal? PriceLimitT1 { get; set; }
        public decimal? PriceLimitT2 { get; set; }
        public decimal? PriceLimitM1 { get; set; }
        public decimal? PriceLimitM2 { get; set; }
        public decimal? NDS { get; set; }
    }

    public class RemnantUpdateRequest
    {
        public List<RemnantUpdate> ArrayOfRemnantsEl { get; set; } = new();
    }

    public class StockUpdateRequest
    {
        public List<StockUpdate> ArrayOfStockEl { get; set; } = new();
    }
}